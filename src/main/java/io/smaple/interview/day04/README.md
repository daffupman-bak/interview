# 面试题收纳（四）

1、单例模式和代理模式

1.1、单例模式

单例模式分为饿汉式和懒汉式，其中懒汉式需要注意线程安全问题。实现的主要步骤：私有化构造方法，并提供一个公共的静态的用于返回实例的方法。

1.2 代理模式

代理模式有静态代理和动态代理。静态代理实现方式比较简单，代理类只要实现与目标类一样的接口，并持有目标类，那么在执行的代理方法中，可以在执行目标对象的方法的前后编写增强代码。而静态代理的缺点也很明显，如果需要代理的类很多，那么我们就需要手动地为每个目标类编写代理类，工作量庞大低效。

动态代理解决了静态代理的问题，可以利用相关技术让程序生成代理类。实现动态代理有两种方式：jdk原生和cglib。jdk原生的实现方式为，代理类实现InvocationHandler，在重写的方法中执行目标类的方法，同时可以做前后增强。cglib需要引入相关依赖，创建Enhancer对象，设置SuperClass和Callback，最后调用`Enhancer#create`返回代理的对象。

2、如何判断一个对象在内存中变为垃圾？

2.1、引用计数法

给对象设置一个引用计数器，每当有一个地方引用它的时候，计数器加一；引用失效时，计数器减一。计数器为0的对象就是垃圾。这个算法实现简单，判定效率高，但是存在多个对象相互引用时，但是这些对象都不再使用了，那么计数器不会计为0，存在内存泄漏的问题。

2.2、可达性分析算法:star:

从`GC Roots`对象为起点，往下搜索，走过的路径称为引用链。那么不在引用链上的对象，则表示它们不可达，即对象不可用。可以做为GC Roots对象的有：虚拟机栈中引用的对象，本地方法栈中引用的对象，方法区中静态成员或常量引用的对象。
